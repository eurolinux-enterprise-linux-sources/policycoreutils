diff -Nur nsapolicycoreutils/audit2allow/audit2allow policycoreutils-2.0.83/audit2allow/audit2allow
--- nsapolicycoreutils/audit2allow/audit2allow	2013-05-02 15:26:30.711224529 +0200
+++ policycoreutils-2.0.83/audit2allow/audit2allow	2013-07-19 12:51:38.506230200 +0200
@@ -325,7 +325,7 @@
                 g.set_module_name(self.__options.module)
 
             if self.__options.output:
-                fd = open(self.__options.output, "w")
+                fd = open(self.__options.output, "a")
             else:
                 fd = sys.stdout
             writer.write(g.get_module(), fd)
diff -Nur nsapolicycoreutils/scripts/fixfiles policycoreutils-2.0.83/scripts/fixfiles
--- nsapolicycoreutils/scripts/fixfiles	2013-05-02 15:26:30.101220606 +0200
+++ policycoreutils-2.0.83/scripts/fixfiles	2013-10-14 21:36:45.979421465 +0200
@@ -31,6 +31,35 @@
 done
 }
 
+exclude_dirs_from_relabelling() {
+    exclude_from_relabelling=
+    if [ -e /etc/selinux/fixfiles_exclude_dirs ]
+    then
+    while read i
+    do
+        # skip blank line and comment
+        # skip not absolute path
+        # skip not directory
+        [ -z "${i}" ] && continue
+        [[ "${i}" =~ "^[[:blank:]]*#" ]] && continue
+        [[ ! "${i}" =~ ^/.* ]] && continue
+        [[ ! -d "${i}" ]] && continue
+        exclude_from_relabelling="$exclude_from_relabelling -e $i"
+        logit "skipping the directory $i from relabelling"
+    done < /etc/selinux/fixfiles_exclude_dirs
+    fi
+    echo "$exclude_from_relabelling"
+}
+
+exclude_dirs() {
+    exclude=
+    for i in /sys /proc /dev /run /mnt /var/tmp /var/lib/BackupPC /home /tmp /dev; do
+    [ -e $i ]  && exclude="$exclude -e $i";
+    done
+    exclude="$exclude `exclude_dirs_from_relabelling`"
+    echo "$exclude"
+}
+
 #
 # Set global Variables
 #
@@ -96,7 +125,7 @@
                   esac; \
                fi; \
             done | \
-		      ${RESTORECON} -f - -R -p  -e /home -e /tmp -r /dev; \
+		      ${RESTORECON} -i -f - -R -p  `exclude_dirs`; \
 	rm -f ${TEMPFILE} ${PREFCTEMPFILE}
 fi
 }
@@ -126,8 +155,31 @@
     return
 fi
 [ -x /usr/sbin/genhomedircon ] && /usr/sbin/genhomedircon
-${SETFILES} -q ${SYSLOGFLAG} ${FORCEFLAG} $* ${FC} ${FILESYSTEMS} 2>&1 | cat >> $LOGFILE
-rm -rf /tmp/gconfd-* /tmp/pulse-* /tmp/orbit-*
+#
+exclude_dirs="`exclude_dirs_from_relabelling`"
+if [ -n "${exclude_dirs}" ]
+then
+    TEMPFCFILE=`mktemp ${FC}.XXXXXXXXXX`
+    TEMPFCBACKUP=`mktemp ${FC}.XXXXXXXXXX.backup`
+    test -z "$TEMPFCFILE" && exit
+    /bin/cp -p ${FC} ${TEMPFCFILE} &>/dev/null || exit
+    /bin/cp -p ${FC} ${TEMPFCBACKUP} &>/dev/null || exit
+    tmpdirs=${tempdirs//-e/}
+    for p in ${tmpdirs}
+    do
+        p="${p%/}"
+        p1="${p}(/.*)? -- <<none>>"
+        echo "${p1}" >> $TEMPFCFILE
+        logit "skipping the directory ${p} from relabelling"
+    done
+/bin/cp $TEMPFCFILE $FC &>/dev/null || exit
+fi
+${SETFILES} $exclude_dirs -q ${SYSLOGFLAG} ${FORCEFLAG} $* ${FC} ${FILESYSTEMS} 2>&1 | cat >> $LOGFILE
+if [ -e $TEMPFCBACKUP ];then
+    /bin/cp -p ${TEMPFCBACKUP} ${FC} &>/dev/null || exit
+    rm -rf ${TEMPFCBACKUP}
+fi
+rm -rf /tmp/gconfd-* /tmp/pulse-* /tmp/orbit-* $TEMPFCFILE
 find /tmp \( -context "*:file_t*" -o -context "*:unlabeled_t*" \) -exec chcon -t tmp_t {} \;
 find /var/tmp \( -context "*:file_t*" -o -context "*:unlabeled_t*" \) -exec chcon -t tmp_t {} \;
 exit $?
diff -Nur nsapolicycoreutils/scripts/fixfiles.8 policycoreutils-2.0.83/scripts/fixfiles.8
--- nsapolicycoreutils/scripts/fixfiles.8	2010-06-16 14:04:12.000000000 +0200
+++ policycoreutils-2.0.83/scripts/fixfiles.8	2013-09-05 12:10:28.045210455 +0200
@@ -29,6 +29,8 @@
 as you expect.  By default it will relabel all mounted ext2, ext3, xfs and 
 jfs file systems as long as they do not have a security context mount 
 option.  You can use the -R flag to use rpmpackages as an alternative.
+The file /etc/selinux/fixfiles_exclude_dirs can contain a list of directories
+excluded from relabeling.
 .P
 .B fixfiles onboot 
 will setup the machine to relabel on the next reboot.
diff -Nur nsapolicycoreutils/semanage/semanage policycoreutils-2.0.83/semanage/semanage
--- nsapolicycoreutils/semanage/semanage	2013-05-02 15:26:30.728224639 +0200
+++ policycoreutils-2.0.83/semanage/semanage	2013-09-18 18:10:40.698343010 +0200
@@ -60,7 +60,7 @@
 semanage module -{a|d|m} [--enable|--disable] module
 semanage node -{a|d|m|l|D|E} [-nrt] [ -p protocol ] [-M netmask] addr
 semanage fcontext -{a|d|m|l|D|E} [-efnrst] file_spec
-semanage boolean -{d|m} [--on|--off|-1|-0] -F boolean | boolean_file
+semanage boolean -{d|l|m} [--on|--off|-1|-0] -F boolean | boolean_file
 semanage permissive -{d|a|l} [-n] type 
 semanage dontaudit [ on | off ]
 
@@ -133,7 +133,7 @@
 		valid_option["fcontext"] += valid_everyone + valid_local + [ '-e', '--equal', '-f', '--ftype', '-s', '--seuser',  '-t', '--type', '-r', '--range'] 
 		valid_option["dontaudit"] = [ '-S', '--store' ]
 		valid_option["boolean"] = []
-		valid_option["boolean"] += valid_everyone + valid_local + [ '--on', "--off", "-1", "-0", "-F", "--file"] 
+		valid_option["boolean"] += ['-h', '--help','-n', '--noheading','-S', '--store','-d', '--delete', '-m', '--modify', '-l','--list'] + valid_local + [ '--on', "--off", "-1", "-0", "-F", "--file"] 
 		valid_option["permissive"] = []
 		valid_option["permissive"] += [ '-a', '--add', '-d', '--delete', '-l', '--list', '-h', '--help', '-n', '--noheading', '-D', '--deleteall' ]
 		return valid_option
@@ -259,7 +259,7 @@
 			if o not in option_dict[object]:
 				sys.stderr.write(_("%s not valid for %s objects\n") % ( o, object) );
 
-                                return
+                                raise usage()
 				
 		for o,a in gopts:
 			if o == "-a" or o == "--add":
@@ -439,6 +439,8 @@
 
 		if modify:
 			if object == "boolean":
+                               if value is None and not use_file:
+                                   raise ValueError(_("Value Required [--on|--off|-1|-0]"))
                                OBJECT.modify(target, value, use_file)
                                return
 
diff -Nur nsapolicycoreutils/semanage/semanage.8 policycoreutils-2.0.83/semanage/semanage.8
--- nsapolicycoreutils/semanage/semanage.8	2013-05-02 15:26:30.771224916 +0200
+++ policycoreutils-2.0.83/semanage/semanage.8	2013-09-05 12:09:10.167617615 +0200
@@ -151,7 +151,7 @@
 .I                \-r, \-\-range      
 MLS/MCS Security Range (MLS/MCS Systems only) SELinux Range for SELinux login mapping defaults to the SELinux user record range. SELinux Range for SELinux user defaults to s0-s0:c0.c1023. 
 .TP
-.I                \-R, \-\-role
+.I                \-R, \-\-roles
 SELinux Roles.  You must enclose multiple roles within quotes, separate by spaces. Or specify \-R multiple times.
 .TP
 .I                \-P, \-\-prefix
diff -Nur nsapolicycoreutils/semanage/seobject.py policycoreutils-2.0.83/semanage/seobject.py
--- nsapolicycoreutils/semanage/seobject.py	2013-05-02 15:26:30.890225681 +0200
+++ policycoreutils-2.0.83/semanage/seobject.py	2013-09-05 12:02:31.424533403 +0200
@@ -197,10 +197,12 @@
 		return raw
 
 def get_valid_types(selinux_class_type):
-    valid_types = []
-    if selinux.is_selinux_enabled():
+    try:
+    #if selinux.is_selinux_enabled():
         valid_types =  setools.seinfo(setools.ATTRIBUTE,selinux_class_type)[0]["types"]
-
+        valid_types.append("<<none>>")
+    except RuntimeError:
+        valid_types = []
     return valid_types
 
 class semanageRecords:
@@ -317,6 +319,8 @@
                        print "%-25s%-10s%s" % (t[0], t[1], disabled)
 
 	def add(self, file):
+               if not os.path.exists(file):
+                      raise ValueError(_("Module does not exists %s ") % file)
                rc = semanage_module_install_file(self.sh, file);
                if rc >= 0:
                       self.commit()
diff -Nur nsapolicycoreutils/setfiles/restore.c policycoreutils-2.0.83/setfiles/restore.c
--- nsapolicycoreutils/setfiles/restore.c	2013-05-02 15:26:30.896225720 +0200
+++ policycoreutils-2.0.83/setfiles/restore.c	2013-10-14 21:37:58.532419048 +0200
@@ -406,7 +406,7 @@
 	size_t i = 0;
 	int errors;
 	memset(&globbuf, 0, sizeof(globbuf));
-	errors = glob(name, GLOB_TILDE | GLOB_PERIOD | GLOB_NOCHECK, NULL, &globbuf);
+	errors = glob(name, GLOB_TILDE | GLOB_PERIOD | GLOB_BRACE | GLOB_NOCHECK, NULL, &globbuf);
 	if (errors) 
 		return errors;
 
diff -Nur nsapolicycoreutils/setsebool/setsebool.8 policycoreutils-2.0.83/setsebool/setsebool.8
--- nsapolicycoreutils/setsebool/setsebool.8	2010-06-16 14:04:13.000000000 +0200
+++ policycoreutils-2.0.83/setsebool/setsebool.8	2013-08-08 16:46:12.205899731 +0200
@@ -4,20 +4,22 @@
 
 .SH "SYNOPSIS"
 .B setsebool
-.I "[ -P ] boolean value | bool1=val1 bool2=val2 ..."
+.I "[ -PV] boolean value | bool1=val1 bool2=val2 ..."
 
 .SH "DESCRIPTION"
 .B setsebool 
 sets the current state of a particular SELinux boolean or a list of booleans 
 to a given value. The value may be 1 or true or on to enable the boolean, or 0 or false or off to disable it. 
 
-Without the -P option, only the current boolean value is 
+Without the \-P option, only the current boolean value is 
 affected; the boot-time default settings 
 are not changed. 
 
-If the -P option is given, all pending values are written to
+If the \-P option is given, all pending values are written to
 the policy file on disk. So they will be persistant across reboots.
 
+If the \-V option is given, verbose error messages will be printed from semanage libraries.
+
 .SH AUTHOR	
 This manual page was written by Dan Walsh <dwalsh@redhat.com>.
 The program was written by Tresys Technology.
diff -Nur nsapolicycoreutils/setsebool/setsebool.c policycoreutils-2.0.83/setsebool/setsebool.c
--- nsapolicycoreutils/setsebool/setsebool.c	2010-06-16 14:04:13.000000000 +0200
+++ policycoreutils-2.0.83/setsebool/setsebool.c	2013-09-17 09:46:22.364612845 +0200
@@ -9,26 +9,30 @@
 #include <pwd.h>
 #include <selinux/selinux.h>
 #include <semanage/handle.h>
+#include <semanage/debug.h>
+#include <semanage/booleans_policy.h>
 #include <semanage/booleans_local.h>
 #include <semanage/booleans_active.h>
 #include <semanage/boolean_record.h>
 #include <errno.h>
 
 int permanent = 0;
+int verbose = 0;
 
 int setbool(char **list, size_t start, size_t end);
 
 void usage(void)
 {
 	fputs
-	    ("\nUsage:  setsebool [ -P ] boolean value | bool1=val1 bool2=val2...\n\n",
+	    ("\nUsage:  setsebool [ -PV ] boolean value | bool1=val1 bool2=val2...\n\n",
 	     stderr);
 	exit(1);
 }
 
 int main(int argc, char **argv)
 {
-	size_t rc, start;
+	size_t rc;
+    int clflag;     /* holds codes for command line flags */
 
 	if (argc < 2)
 		usage();
@@ -38,37 +42,53 @@
 		return 1;
 	}
 
-	if (strcmp(argv[1], "-P") == 0) {
-		permanent = 1;
-		if (argc < 3)
-			usage();
-		start = 2;
-	} else
-		start = 1;
+    while (1) {
+        clflag = getopt(argc, argv, "PNV");
+        if (clflag == -1)
+            break;
+
+        switch (clflag) {
+        case 'P':
+            permanent = 1;
+            break;
+        case 'V':
+            verbose = 1;
+            break;
+        default:
+            usage();
+            break;
+        }
+    }
+
+    if (argc - optind < 1) {
+        fprintf(stderr, "Error: boolean name required\n");
+        usage();
+    }
+
 
 	/* Check to see which way we are being called. If a '=' is passed,
 	   we'll enforce the list syntax. If not we'll enforce the original
 	   syntax for backward compatibility. */
-	if (strchr(argv[start], '=') == 0) {
+	if (strchr(argv[optind], '=') == 0) {
 		int len;
 		char *bool_list[1];
 
-		if ((argc - start) != 2)
+		if ((argc - optind) != 2)
 			usage();
 
 		/* Add 1 for the '=' */
-		len = strlen(argv[start]) + strlen(argv[start + 1]) + 2;
+		len = strlen(argv[optind]) + strlen(argv[optind + 1]) + 2;
 		bool_list[0] = (char *)malloc(len);
 		if (bool_list[0] == 0) {
 			fputs("Out of memory - aborting\n", stderr);
 			return 1;
 		}
-		snprintf(bool_list[0], len, "%s=%s", argv[start],
-			 argv[start + 1]);
+		snprintf(bool_list[0], len, "%s=%s", argv[optind],
+			 argv[optind + 1]);
 		rc = setbool(bool_list, 0, 1);
 		free(bool_list[0]);
 	} else
-		rc = setbool(argv, start, argc);
+		rc = setbool(argv, optind, argc);
 
 	return rc;
 }
@@ -101,6 +121,7 @@
 	semanage_bool_t *boolean = NULL;
 	semanage_bool_key_t *bool_key = NULL;
 	int managed;
+    int result;
 
 	handle = semanage_handle_create();
 	if (handle == NULL) {
@@ -108,6 +129,10 @@
 		goto err;
 	}
 
+    if (! verbose) {
+        semanage_msg_set_callback(handle,NULL, NULL);
+    }
+
 	managed = semanage_is_managed(handle);
 	if (managed < 0) {
 		fprintf(stderr,
@@ -140,12 +165,21 @@
 		if (semanage_bool_key_extract(handle, boolean, &bool_key) < 0)
 			goto err;
 
+        semanage_bool_exists_local(handle, bool_key, &result);
+        if ( !result ) {
+            semanage_bool_exists(handle, bool_key, &result);
+            if ( !result ) {
+                fprintf(stderr, "Boolean %s is not defined\n", boollist[j].name);
+                goto err;
+            }
+        }
+
 		if (semanage_bool_modify_local(handle, bool_key,
 						  boolean) < 0)
 			goto err;
 
 		if (semanage_bool_set_active(handle, bool_key, boolean) < 0) {
-			fprintf(stderr, "Could not change boolean %s\n",
+            fprintf(stderr, "Could not change boolean %s\n",
 				boollist[j].name);
 			goto err;
 		}
@@ -167,7 +201,7 @@
 	semanage_bool_key_free(bool_key);
 	semanage_bool_free(boolean);
 	semanage_handle_destroy(handle);
-	fprintf(stderr, "Could not change policy booleans\n");
+    //fprintf(stderr, "Could not change policy booleans\n");
 	return -1;
 }
 
